def uniform_cost_search(graph, start, goal):
    Q = PriorityQueue()  # Priority queue ordered by cost
    visited = set()      # Set to keep track of visited nodes
    cost = {}            # Dictionary to store cumulative costs
    parent = {}          # Dictionary to store parent nodes

    # Initialize
    Q.put((0, start))    # (cost, node)
    cost[start] = 0
    parent[start] = None

    while not Q.empty():
        current_cost, u = Q.get()  # Get the node with the lowest cost

        if u == goal:
            # Reconstruct path
            path = []
            while u is not None:
                path.append(u)
                u = parent[u]
            return path[::-1], current_cost  # Return reversed path and total cost

        visited.add(u)

        for v, edge_cost in graph.neighbors(u):
            if v not in visited:
                new_cost = cost[u] + edge_cost
                if v not in cost or new_cost < cost[v]:
                    cost[v] = new_cost
                    parent[v] = u
                    Q.put((new_cost, v))

    return None  # No path found
